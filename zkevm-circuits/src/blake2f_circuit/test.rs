use super::{wit_gen::InputValuesParse, Blake2fCircuit};
use eth_types::Field;
use halo2_proofs::dev::MockProver;
use std::hash::Hash;

fn test_blake2f_circuit<F: Field + Hash>(inputs: &[Vec<u8>]) {
    let circuit = Blake2fCircuit::new(&inputs);
    let prover: MockProver<F> = MockProver::run(9, &circuit, Vec::new()).unwrap();
    let result = prover.verify();
    if let Err(failures) = &result {
        for failure in failures.iter() {
            println!("{}", failure);
        }
    }
}

#[test]
fn test_blake2f_example() {
    use halo2_proofs::halo2curves::bn256::Fr;

    let s = String::from("0000000c48c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b61626300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000001");

    let v = (0..s.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&s[i..i + 2], 16).unwrap())
        .collect();

    test_blake2f_circuit::<Fr>(&[v]);
}

#[test]
fn test_blake2f_multi_inputs() {
    use halo2_proofs::halo2curves::bn256::Fr;

    let input1 = InputValuesParse::new_from_str(String::from("0000000c48c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b61626300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000001"));
    let input2 = InputValuesParse::new_from_str(String::from("0000000c48c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b61626300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000"));
    let input3 = InputValuesParse::new_from_str(String::from("0000000048c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b61626300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000001"));
    let input4 = InputValuesParse::new_from_str(String::from("0000000148c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b61626300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000001"));

    // let multi_rounds = vec![input1.rounds, input2.rounds, input3.rounds, input4.rounds];
    let muilt_inputs = vec![input1, input2, input3, input4];

    // let super_circuit = blake2f_super_circuit::<Fr>(muilt_inputs.len(), multi_rounds);
    // let compiled = chiquitoSuperCircuit2Halo2(&super_circuit);

    // let circuit = ChiquitoHalo2SuperCircuit::new(
    //     compiled,
    //     super_circuit.get_mapping().generate(muilt_inputs),
    // );
    let circuits = Blake2fCircuit::new_input(muilt_inputs);

    let prover: MockProver<Fr> = MockProver::run(9, &circuits, Vec::new()).unwrap();
    let result = prover.verify();

    println!("result = {:#?}", result);

    if let Err(failures) = &result {
        for failure in failures.iter() {
            println!("{}", failure);
        }
    }
}
